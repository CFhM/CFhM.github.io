<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用visual studio编译运行汇编程序]]></title>
    <url>%2F2017%2F10%2F18%2Fasm-1%2F</url>
    <content type="text"><![CDATA[前言 ​ 本文结合这篇文章提供了在Visual Studio 2017中利用masm依赖，在c++项目中编写、编译、运行汇编语言的方法。本文兼容Visual Studio 2012及以上版本。 ​ 笔者系统环境如下： OS ：Windows 10 Insider Preview, Build 17017 VS ：Visual Studio 2017 Windows SDK: 15063.0 新建空白项目 在visual studio的菜单栏选择文件-新建-项目，并新建win32 控制台程序的空项目（vs2015及以前的版本请参考该版本的新建方式） 为项目添加masm依赖 在项目资源管理器中右键项目，点击生成依赖项，勾选 masm 设置subsystem 右键项目-属性，在属性面板中展开链接器-高级，将subsystem设置为Console或Windows 编写asm代码 在源文件文件夹上右键添加-新项目，将.cpp文件重命名为.asm文件，并填入下面的测试代码。 123456789101112131415; AddTwo.asm - adds two 32-bit integers..386.model flat,stdcall.stack 4096ExitProcess proto,dwExitCode:dword.codemain proc mov eax,5 add eax,6 invoke ExitProcess,0main endpend main 设置 entry point（可选） 如下图所示，本程序的入口即默认入口main，若程序入口不为main则需在项目属性-高级-入口点自行设置 [1] 语法高亮由AsmDude插件支持[2] 1.同样需要在项目资源管理器中右键 ↩2.该插件需要在vs的工具-扩展与更新中下载 ↩]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode编译运行以及配置debug C/C++]]></title>
    <url>%2F2017%2F09%2F16%2Fvscode-2%2F</url>
    <content type="text"><![CDATA[vscode 使用脚本编译C/C++ 关于gcc / g++ 编译命令 详细内容参考这篇博客 这里介绍常用的命令： 假设你的C文件叫做ff.c，那么编译他的命令就是gcc ff.cpp -o ff，这时你的源程序目录下就会生成可执行文件ff.exe 再在终端下执行ff（cmd）或./ff（powershell）就可以运行 指定编译的C语言标准：-std=c11（设为c11标准） 静态编译：-static 开启O2级别优化：-O2 使用.bat脚本实现自动化编译运行 首先若要在vscode的集成的终端中运行文件，必须以打开文件夹的方式编写你的程序 假设你的文件夹的绝对路径是C:\Users\ff\Desktop，那么我们的.bat文件也要放在这个目录下。 下面是我的.bat文件的示例 1234@echo offcd C:\Users\ff\Desktop\ffgcc test.c -o test -std=c11 -O2test 下面是简单的解释： 关闭命令回显 打开工作目录（替换成你的工作目录） 以c11标准 O2优化编译test.c文件（替换成你自己的.c文件） 并声称test.exe可执行文件 运行test.exe 将上面的文件保存在你的目录下，命名为run.bat，在vscode中按ctrl+` 打开终端 输入run（cmd）或./run（powershell）即可运行查看结果 结合分屏的输入输出重定向方法 很多时候我们需要向程序输入大量的数据，一个个手动输入就会特别繁琐，因此我们需要学习将输入输出重定向到文件中，这样只要一次将输入写入文件，此后就不需要再次输入重复的内容了。 vscode的分屏功能 按ctrl+\开启分屏功能，vscode中最多可以分左中右三屏，我们在文件夹下创建两个文件in.txt和out.txt分别作为输入和输出被重定向的文件，并分别在左右屏打开，如图所示 向左移动编辑器组的快捷键是ctrl+k leftarrow，向右为ctrl+k rightarrow 三个屏从左到右依次标号为1、2、3，切换焦点到对应的编辑器的快捷键为ctrl+1/2/3 重定向输入输出 freopen 123456int main() &#123; freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); // your code&#125; 将上面两句freopen加到main函数的最前面即可，关于文件读写的其他操作欢迎关注后续的博客。 运行时重定向 上述做法有一个明显的弊端——算法竞赛时需要从标准的输入输出来读取，因此我们在本地测试完提交自己的代码到OJ上面时需要注释掉这两句话，而新手甚至老手都会常常忘记这一点，造成无谓的WA，因此需要下面的方法。 将run.bat中运行test.exe的命令test后加上&lt;in.txt &gt;out.txt即可，效果如图： vscode配置C/C++ debug 配置launch.json文件 在左侧栏中选择第四项打开debug侧栏，点击上方的绿色箭头，会弹出选择环境，选择C++(GDB/LLDB)，提示没有配置，选择打开launch.json，选择C++(GDB/LLDB) 将下面的内容复制到你的文件中，并按注释修改相关内容 12345678910111213141516171819&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "launchOptionType": "Local", // 调试器启动类型，这里只能为Local "targetArchitecture": "x86", // 生成目标架构，一般为x86或x64，可以为x86, arm, arm64, mips, x64, amd64, x86_64 "program": "$&#123;file&#125;.exe", // 将要进行调试的程序的路径 "miDebuggerPath":"C:\\MinGW\\bin\\gdb.exe", // miDebugger的路径，注意这里要与MinGw的路径对应 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceRoot&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "preLaunchTask": "gcc" // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &#125; ]&#125; 配置task.json文件 再次点击绿色箭头，点击配置任务运行程序，任意选择一项生成命令，编辑task.json文件如下： 1234567891011121314151617&#123; "version": "0.1.0", "command": "gcc", "args": ["-g","$&#123;file&#125;","-o","$&#123;file&#125;.exe"], // 编译命令参数 "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "$&#123;workspaceRoot&#125;"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;&#125; 这时再点击绿色小箭头，或在.c文件处于焦点状态时（即光标在.c）文件处按F5即可出现如下图的调试界面 至此我们的配置工作全部完成 常用快捷键 下一步F10 单步运行F11 停止Shift+F5]]></content>
      <categories>
        <category>Development Tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 BITCS 小学期程设总结赛题解]]></title>
    <url>%2F2017%2F09%2F15%2Fsol1%2F</url>
    <content type="text"><![CDATA[Problem 1 Solution 只有同时进来的人才能保证不是同一个人，所以记录人数的最大值和最小值，做差就是要求的答案。 Code 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int T; scanf("%d", &amp;T); char c; getchar(); while(T--) &#123; int mx = 0, mi = 2000, cnt = 0; while(~scanf("%c", &amp;c)) &#123; if(c == '\n') break; if(c == '+') cnt++; else cnt--; mx = (mx &gt;= cnt ? mx : cnt); mi = (mi &lt;= cnt ? mi : cnt); &#125; printf("%d\n", mx - mi); &#125;&#125; Problem 2 Solution 看上去是一个背包问题，但是由于物体的大小只有1和2，所以可以转换为贪心的方式去做。 首先考虑这样一个性质，若要装进物品，则对于相同体积的，一定优先考虑美味度大的，所以对两种物品分别按照美味度降序排序，那么一定是贪心地从大往小装入物品。 由于体积的不同，所以单位体积的物品有着不同的美味度，但是受到容量的限制，我们从单位体积这个角度去思考会很难处理诸如：若除以2来计算，那么存在精度问题；若乘2计算，还要考虑是否能放下原本体积为1的物品。 故考虑这样一个思路：对容量为VVV的背包，若其中MMM放体积为2的物品，则剩下V−MV-MV−M的部分放体积为1的物品，这样我们就可以枚举在背包中放体积为2的物品的数量，统计最大的答案即可。 由于每次选择物品一定是这两个序列的前缀和，所以可以进行前缀和的优化，最终算法复杂度为O(n)O(n)O(n)。 Code by V5ZSQ 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef long long ll;#define maxn 100005int n, V, a[maxn], b[maxn];ll sa[maxn], sb[maxn];int cmp(const void *a, const void *b) &#123; return *(int *)b - *(int *)a;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;V); int na = 0, nb = 0; int x, y; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;x, &amp;y); if (x == 2) a[++na] = y; else b[++nb] = y; &#125; qsort(a + 1, na, sizeof(int), cmp); qsort(b + 1, nb, sizeof(int), cmp); sa[0] = sb[0] = 0; for (int i = 1; i &lt;= na; i++) sa[i] = sa[i - 1] + a[i]; for (int i = 1; i &lt;= nb; i++) sb[i] = sb[i - 1] + b[i]; ll ans = 0; for (int i = 0; i &lt;= na &amp;&amp; 2 * i &lt;= V; i++) &#123; int j = V - 2 * i; if (j &lt; 0) j = 0; if (j &gt; nb) j = nb; if (sa[i] + sb[j] &gt; ans) ans = sa[i] + sb[j]; &#125; printf("%lld\n", ans); return 0;&#125; Code by CFhM_R in C++ 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define rep(i, a, b) for(int i = (a); i &lt; (b); ++i)typedef long long ll;const int maxn = 1e5 + 5;// headll a[maxn], b[maxn];int main() &#123; int n, v; scanf("%d%d", &amp;n, &amp;v); int t, p, cnt1 = 1, cnt2 = 1; rep(i, 0, n) &#123; scanf("%d%d", &amp;t, &amp;p); if(t == 1) a[cnt1++] = (ll)p; else b[cnt2++] = (ll)p; &#125; sort(a + 1, a + cnt1, [&amp;](ll a, ll b)&#123; return a &gt; b; &#125;); sort(b + 1, b + cnt2, [&amp;](ll a, ll b)&#123; return a &gt; b; &#125;); ll ans = 0ll, sum = 0ll; rep(i, 2, cnt1) a[i] += a[i - 1]; rep(i, 0, cnt2) &#123; if(i * 2 &gt; v) break; sum += b[i]; int pos = (v - 2 * i &gt;= cnt1 ? cnt1 - 1 : v - 2 * i); ans = max(ans, sum + (pos ? a[pos] : 0)); &#125; printf("%lld\n", ans); return 0;&#125; Problem 3 Solution 可以看出这是一道01背包的模型题，不同的是本题要求背包用量大于等于mmm时的最小值，故背包 上限应为mmm上限再加一个物品上限（不可能多两个物品构造最优解）。之后从mmm到 2000的dp值取最小即可。 Code by V5ZSQ 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 1005#define INF 1e7#define min(x, y) ((x) &lt; (y) ? (x) : (y))int n, m, a[maxn], b[maxn], dp[2 * maxn];int main() &#123; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); for (int i = 0; i &lt;= 2000; i++) dp[i] = INF; dp[0] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 2000; j &gt;= a[i]; j--) dp[j] = min(dp[j], dp[j - a[i]] + b[i]); int ans = dp[m]; for (int i = m; i &lt;= 2000; i++) ans = min(ans, dp[i]); if (ans == INF) printf("My small xueqi ended!\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem 4 Solution 考虑b数组的下面一些性质： b数组的元素代表的是出现的次数，因此这个次数一定不会超过nnn，所以所有超过nnn的a[i]a[i]a[i]对应的b[i]b[i]b[i]一律是0。 若a[i]==a[j](i≠j)a[i] == a[j](i \neq j)a[i]==a[j](i≠j)，一定有b[i]==b[j]b[i] == b[j]b[i]==b[j]。 对于所有不同的a[i]a[i]a[i]，b[i]b[i]b[i]的和&lt;=n&lt;=n&lt;=n 通过上面的性质可以总结出一些剪枝的方法，由此可以暴力枚举dfs b数组的方案，加上上述剪枝，即可通过本题。 Code by V5ZSQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n, num[1000005], a[maxn], b[maxn], ans[maxn], flag;int check(int k) &#123; for (int i = 1; i &lt;= k; i++) if (num[a[i]] &gt; b[i]) return 0; int sum = 0; for (int i = 1; i &lt;= k; i++) &#123; int mark = 0; for (int j = 1; j &lt; i; j++) if (a[j] == a[i]) &#123; if (b[i] != b[j]) return 0; mark = 1; &#125; if (!mark) &#123; sum += b[i]; if (sum &gt; n) return 0; &#125; &#125; return 1;&#125;void dfs(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) if (num[a[i]] != b[i]) return; if (flag) &#123; for (int i = 1; i &lt;= n; i++) if (b[i] &gt; ans[i]) return; &#125; flag = 1; for (int i = 1; i &lt;= n; i++) ans[i] = b[i]; return; &#125; if (a[k] &gt; n) &#123; b[k] = 0; num[0]++; dfs(k + 1); num[0]--; return; &#125; for (int i = 0; i &lt;= n; i++) &#123; b[k] = i; num[i]++; if (check(k)) dfs(k + 1); num[i]--; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); memset(num, 0, sizeof(num)); flag = 0; dfs(1); if (flag) for (int i = 1; i &lt;= n; i++) printf("%d%c", ans[i], i == n ? '\n' : ' '); else printf("do not exist\n"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>题解</tag>
        <tag>BITCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言从入门到懵逼（三）]]></title>
    <url>%2F2017%2F09%2F12%2FC3%2F</url>
    <content type="text"><![CDATA[while循环 123while(condition) &#123; // do something&#125; 123do &#123; // do something&#125; while(condition) 当型和直到型的区别 常见套路 T组用例 12345int T;scanf("%d", &amp;T);while(T--) &#123; // do something&#125; 文件结束 12345678int n;while(~scanf("%d", &amp;n)) &#123; // do something&#125;while(scanf("%d", &amp;n) != EOF) &#123; // EOF == End Of File // do something&#125; 某些用if判定终止的循环 12345while(true) &#123; if(condition) break; // do something&#125; 自加与循环结合——变量终止时的值 (i == 5) 12int i = 0;while(i++ &lt; 4) ; 冒泡排序 演示 123456789101112131415#include &lt;stdio.h&gt;int main() &#123; int a[10]; for(int i = 0; i &lt; 10; i++) scanf("%d", &amp;a[i]); for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10 - i; j++) &#123; if(a[j] &gt; a[j + 1]) &#123; int tmp = a[j + 1]; a[j + 1] = a[j]; a[j] = tmp; &#125; &#125; &#125;&#125; 思考：交换两个元素 不借助第三方变量 1234int x, y;x += y;y = x - y;x -= y; anything else?]]></content>
      <categories>
        <category>C语言从入门到懵逼</category>
      </categories>
      <tags>
        <tag>C语言从入门到懵逼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言从入门到懵逼（二）]]></title>
    <url>%2F2017%2F09%2F12%2FC2%2F</url>
    <content type="text"><![CDATA[数据和数据类型 分类存储 节约空间 类型分明 运算体系（数据在计算机中的表示） long long double那些事 %lf 输入 %f 输出 %占位 左右对齐？补零？ 选择结构 if-else 一行可以没有花括号 可以嵌套 内部全集 同级无交 三目运算 ：f(x) ? g(y) : h(z); 12if(f(x) == true) g(y); else h(z); == 和 = 双目运算 不能连续比较 用逻辑关系表示 短路性质 &amp;&amp;前为假 ||前为真 switch-case 枚举 12345678910111213switch(变量)&#123; case value1: //do sth break; case value2: case value3: //do sth break default: //do sth break;&#125; 顺序执行 直到遇到break 执行相同语句可以合并case 冒号 default操作 防止异常 数组 多个相同类型的变量连续排列 在内存中表现为地址相差size []索引下标 默认赋值随机——一定要初始化！！！ 起始为0 终止为n-1 小心越界！！！ 大数据范围多开5个 循环结构 for循环 1for(迭代变量赋初值; 终止条件; 迭代更新) 分号不可少 其他都可少 用for循环完成对数组的操作 用for循环和if条件完成对特定元素的操作 12345int a[10];for(int i = 0; i &lt; 10; i++)&#123; //do sth&#125; 123for(;;) &#123; if(可达到条件) break;&#125; 不出现死循环 不越界 就是合法的]]></content>
      <categories>
        <category>C语言从入门到懵逼</category>
      </categories>
      <tags>
        <tag>C语言从入门到懵逼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言从入门到懵逼（一）]]></title>
    <url>%2F2017%2F09%2F12%2FC1%2F</url>
    <content type="text"><![CDATA[美好的想法经过美好的代码创造美丽的世界——写在前面 怎样写代码 IDE 集成开发环境（Integrated Development Environment，简称IDE，也称为Integration Design Environment、Integration Debugging Environment）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形界面 C语言从入门到懵逼(一) By CFhM_R 写怎样的代码 格式的规范 运算符左右空格 代码块之间的缩进 不同功能语句块之间的空行 充分的注释——别相信自己的代码谁都能看懂 对比 命名的规范 杜绝无意义变量名（算法竞赛部分例外） 变量名：lowerCamel 静态/私有变量：s_lower_letter 函数名（方法名）/类名/包名：UpperCamel 保持一致性 我该如何学习编程——从兴趣到习惯 写博客 每天一写 学了哪些新的东西 做了什么程序 思考/改进了哪些 新知识 阶段总结 常错集锦 常思考 代码是否可以再次优化？ 问题是否有别的解法？是否更优？ 重要的不是结果，而是思考的过程 多读书 理论与实践相结合 读书与思考相结合 C++ Prime， C Prime，The C Programming Language，代码大全，算法导论，挑战程序设计竞赛，Thinking in Java，CLR via C#，Learning Python 多实践 c++需要不断地练习——vczh github读源码 小项目而不是a+b 多交流 总有比你牛逼的人 真诚 价值互换 多检查 写一点就要做测试 学好英语 英文文档 国外网站 cppreference quora stackoverflow msdn等 ACM题目 遇到困难？ 独立思考 查阅资料 与他人交流确认 有礼，逻辑清楚地求助他人]]></content>
      <categories>
        <category>C语言从入门到懵逼</category>
      </categories>
      <tags>
        <tag>C语言从入门到懵逼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode安装及使用coderunner运行C程序教程]]></title>
    <url>%2F2017%2F09%2F11%2Fvscode-1%2F</url>
    <content type="text"><![CDATA[vscode简介 ​ vscode 全称 visual studio code，是一个运行于 OS X，Windows 和 Linux 之上的，针对于编写现代web和云应用的跨平台编辑器。除了上述提到的，它在c/c++的编写上也有非常优秀的表现，并且有着十分友好的快捷键以及可以高度自定义等特性。他是一款轻量级的编辑器，但丰富的插件又使其不失灵巧性，当你觉得visual studio太过笨重/难以使用/功能太多用不到时，不妨试试这款可以由你亲自定义的编辑器。 ​ 下面是两张vscode编写c程序hello world以及debug的图示 ​ 上图中，中间区域为编写区域，可以看到vscode有良好的分屏支持，左边的分屏1为输入文件，右侧的分屏3为输出文件，下方为集成的terminal（可选cmd或ps），运行简单的编译脚本，就可以完成对程序的编译和运行了。 ​ 上图为vscode debug C程序时的调试界面，分别可以实现对当前变量、用户变量、程序线程和断点的监控。 ​ 今天我们介绍的就是如何在windows平台上安装vscode并很方便的使用它来编写C/C++程序。 vscode的安装 下载vscode安装程序 访问vscode官方网站：https://code.visualstudio.com/ 选择适合系统版本的安装包进行下载（x64/x86） 运行安装文件 安装路径一定要在C盘，不然后面的编译功能和代码提示功能会受到影响（对C盘文件访问权限的问题）。 将其他中的选项全部打勾。 安装 vscode简单配置 常用插件 对于将要编写C/C++的新手，下面几款插件是推荐安装使用的 VScode Great Icons：文件图标插件 One Monokai Theme：主题插件 C/C++：C/C++代码提示、编译、运行等集成插件 Code Runner：简易代码一键运行插件 ​ 上述内容在vscode左侧栏最后一项扩展页面中可以搜索下载，下载完成后需点击重新加载（下载完所有插件后点一次即可）。 配置主题 在菜单栏依次点击文件-首选项-颜色主题，选择One Monokai 其他主题也可依照提示进行安装并使用，本主题为示例图片所用主题 配置文件图标 在菜单栏依次点击文件-首选项-文件图标主题，选择VSCode Great Icons 其他主题也可依照提示进行安装并使用，本主题为示例图片所用主题 所有设置 vscode的所有设置是以json文件进行存储的，点击文件-首选项-设置即可配置，须在右侧分栏写入自己的配置，每个设置项在默认栏处都有详细的注释，有兴趣的朋友可以耐心阅读并选择适合自己的配置。下面是博主所用配置。 1234567891011121314&#123; "workbench.iconTheme": "vscode-great-icons", "workbench.colorTheme": "One Monokai", "terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe", "editor.snippetSuggestions": "top", "editor.fontSize": 15, "editor.wordWrap":"on", "editor.fontFamily": "Consolas,Courier New, monospace", "files.autoSave": "off", "window.zoomLevel": 0, "C_Cpp.intelliSenseEngineFallback": "Enabled", "C_Cpp.errorSquiggles": "Disabled", "editor.tabSize": 4&#125; vscode编写并运行C/C++程序 配置mingw g++编译器 点我下载mingw下载工具 运行下载工具，一路选择continue（安装路径在C盘千万不要改），等待下载组件 之后会弹出Installation Manager，在左侧选择All Packages 在右边的选项列表中依次勾选(右键Mark for Installation)class为bin 的mingw32-binutils，mingw32-gcc，mingw32-g++，mingw32-gdb，期间系统还会自动勾选一些选项，不要管他 在最上方的菜单栏中选择Installation-Apply Changes，在弹出的选项卡中点击Apply，等待所有组件被下载安装完成。 设置系统环境变量 ​ 由于各个版本的windows差别较大，这里仅介绍windows10的配置方法，其余的环境变量设置方式请自行搜索或在博客下留言。 在Cortana搜索框中输入环境变量，并点击进入编辑系统环境变量 将mingw的bin目录加入你的环境变量，若你的mingw是默认安装，则环境变量为C:\MinGW\bin 一路确定并重启计算机 测试你的C/C++编译器 使用win+R调出运行界面，输入cmd回车运行命令提示符，输入gcc并回车 若显示gcc: fatal error: no input files compilation terminated.则说明安装成功 vscode编写运行C程序 ​ 这里仅介绍使用Code Runner插件编译运行的方法，当读者学会gcc编译器的操作后，自然可以自行完成脚本来实现带有其他编译命令的运行方式。 在桌面新建一个文件夹，例如ff（一定要在文件夹下才能运行Code Runner） 右键该文件夹，选择Open with Code Ctrl+N新建一个文件，Ctrl+S保存为.c文件，如test.c 编写简单的C示例程序Hello World 编写完成后Ctrl+S保存（保存很重要！） Ctrl+Alt+N运行，可以看到输出结果 以上就是vscode的安装、配置以及编写C程序的详细教程。 后续还有使用脚本自定义编译命令、输入输出重定向到文件、使用debug功能调试代码等教程，欢迎持续关注本博客~]]></content>
      <categories>
        <category>Development Tools</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>vscode</tag>
        <tag>Mingw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFhM xjb training 题解]]></title>
    <url>%2F2017%2F09%2F11%2Fsol2%2F</url>
    <content type="text"><![CDATA[A-Number Busters-推公式 当b&lt;xb&lt;xb&lt;x时，aaa和ccc都会减小，c−ac - ac−a不会改变，所以只有在b≥xb \geq xb≥x的时候，才会使aaa和ccc之间的距离缩短，所以我们知道b≥xb \geq xb≥x这个状态共出现c−ac - ac−a秒。 再来看b < x​的时间，假设有k​秒，且易知使c = a​这个临界点出现的状态必然是b \geq x​，此时（更新之后）b​的值为b - x * (c - a) + k * (w - x)​，那么这个值还原回去（加上x​）必须大于等于x​。 由此得出方程b−x∗(c−a)+k∗(w−x)+x≥xb - x * (c - a) + k * (w - x) + x \geq xb−x∗(c−a)+k∗(w−x)+x≥x 解出kkk，再加上b≥xb \geq xb≥x的时间c−ac - ac−a，就是最终的答案 1234567891011121314151617181920int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif ll a, b, w, x, c; scan(a, b, w); scan(x, c); ll ans = 0LL; if(c &gt; a) ans = ceil(1.0 * ((c - a) * x - b) / (w - x)) + c - a; dbg(ans); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; B-ZYB loves Xor I-分治 这里的lowbit(x)lowbit(x)lowbit(x)的定义和我们以前知道的那个一样 网上的题解都是字典树，然而学艺不精 刘庆晖老师教导的分治的思维，让我看到了希望 对于一个数组aaa，我们考虑它的最低位是否为1，可以分为两个集合，这两个集合中任意两个数做异或的结果的lowbitlowbitlowbit，都是1。 对于第一个集合，由于最低位相同（都是1），那么考虑第二位（次低位），按照上面的描述再次分为两个集合，那么这两个集合中任意两个数的异或的lowbitlowbitlowbit都是2。 对于第二个集合同理。 之后对于再次划分的集合我们发现依然可以这样分治下去。 wow~ 最后我们构造的就是一棵2n−12^n - 12​n​​−1个节点的解答树 复杂度是O(nlogn∗T)O(nlogn * T)O(nlogn∗T) 12345678910111213141516171819202122232425262728293031323334353637383940void gao(vi &amp;vec, int pos, ll &amp;ans) &#123; vi vec1, vec2; for(auto v : vec) &#123; if(v &amp; (1 &lt;&lt; pos)) vec1.pb(v); else vec2.pb(v); &#125; ans += (ll)(1LL &lt;&lt; pos) * vec1.size() * vec2.size() % MOD; if(pos &gt;= 28) return; if(vec1.size() &gt; 0) gao(vec1, pos + 1, ans); //剪枝很重要 if(vec2.size() &gt; 0) gao(vec2, pos + 1, ans);&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif int T; scan(T); rep(i, 0, T) &#123; vi vec; int n, x; scan(n); while(n--) &#123; scan(x); vec.pb(x); &#125; ll ans = 0LL; gao(vec, 0, ans); ans = ans * 2LL % MOD; printf("Case #%d: %lld\n", i + 1, ans); &#125; #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; C-Wavy numbers-Q神代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;using namespace std;typedef long long ll;const int MAXQ=10000000;const int MAXL=14;int vis[MAXQ],num[MAXL];int change(int t)&#123; int now=0; while(t) &#123; num[now++]=t%10; t/=10; &#125; return now;&#125;unordered_map&lt;ll,int&gt;mp[2][10];void solve_right(ll n,ll &amp;k)&#123; for(int i=1;i&lt;MAXQ;i++) &#123; int t=change(i),ok=1; if(t==2)ok&amp;=(num[0]!=num[1]); for(int j=1;j&lt;t-1;j++) ok&amp;=((num[j]&gt;num[j-1] &amp;&amp; num[j]&gt;num[j+1]) ||(num[j]&lt;num[j-1] &amp;&amp; num[j]&lt;num[j+1])); if(!ok)continue; vis[i]=1; k-=(i%n==0); if(k==0) &#123; printf("%d",i); exit(0); &#125; if(t==6 &amp;&amp; num[t-1]&gt;num[t-2])mp[0][0][i%n]++; else if(t==7)mp[num[t-1]&gt;num[t-2]][num[t-1]][i%n]++; &#125;&#125;void get_res(ll n,ll &amp;k,ll Mod,int lef)&#123; int len=7; while(lef) &#123; num[len++]=lef%10; lef/=10; &#125; for(int i=1;i&lt;MAXQ;i++) &#123; if(!vis[i])continue; int t=change(i),ok=1; while(t&lt;7)num[t++]=0; t=len; for(int j=1;j&lt;t-1;j++) ok&amp;=((num[j]&gt;num[j-1] &amp;&amp; num[j]&gt;num[j+1]) ||(num[j]&lt;num[j-1] &amp;&amp; num[j]&lt;num[j+1])); if(!ok)continue; k-=(i%n==Mod); if(k==0) &#123; printf("%07d",i); exit(0); &#125; &#125;&#125;void solve_left(ll n,ll &amp;k)&#123; for(int i=1;i&lt;MAXQ;i++) &#123; if(!vis[i])continue; int t=change(i),ok=1; if(t==2)ok&amp;=(num[0]!=num[1]); for(int j=1;j&lt;t-1;j++) ok&amp;=((num[j]&gt;num[j-1] &amp;&amp; num[j]&gt;num[j+1]) ||(num[j]&lt;num[j-1] &amp;&amp; num[j]&lt;num[j+1])); if(!ok)continue; ll m=(n-1LL*i*MAXQ%n)%n,cnt=0; if(t==1) &#123; for(int j=0;j&lt;num[0];j++) if(mp[0][j].find(m)!=mp[0][j].end()) cnt+=mp[0][j][m]; for(int j=num[0]+1;j&lt;10;j++) if(mp[1][j].find(m)!=mp[1][j].end()) cnt+=mp[1][j][m]; &#125; else &#123; int go=(num[1]&gt;num[0]); if(go==0)for(int j=0;j&lt;num[0];j++) if(mp[0][j].find(m)!=mp[0][j].end()) cnt+=mp[0][j][m]; if(go==1)for(int j=num[0]+1;j&lt;10;j++) if(mp[1][j].find(m)!=mp[1][j].end()) cnt+=mp[1][j][m]; &#125; if(k&lt;=cnt) &#123; printf("%d",i); get_res(n,k,m,i); &#125; else k-=cnt; &#125;&#125;int main()&#123; ll n,k; scanf("%lld%lld",&amp;n,&amp;k); solve_right(n,k); solve_left(n,k); return 0*printf("-1");&#125; D-Bear and Floodlight-计算几何 只有20盏灯，所以可以考虑用状压dp，dp[i]dp[i]dp[i]表示iii代表的状态（1表示亮）能走的最远距离 转移就是枚举剩下的未亮的灯，点亮后能走的距离。 对于状态dp[i]dp[i]dp[i]点亮灯jjj之后的状态分两种情况： 由dp[i]dp[i]dp[i]的终点开始向rrr照亮θj\theta_jθ​j​​的范围，那么有dp[i∣(1&lt;&lt;j)]=(arctan((dp[i]−xj)/yj)+θj)∗yj+xj−ldp[i | (1 &lt;&lt; j)] = (arctan((dp[i] - x_j) / y_j) + \theta_j) * y_j + x_j - ldp[i∣(1&lt;&lt;j)]=(arctan((dp[i]−x​j​​)/y​j​​)+θ​j​​)∗y​j​​+x​j​​−l 若该角度超过r，则取r−lr - lr−l 123456789101112131415161718192021222324252627282930313233343536373839404142434445double l, r;struct point &#123; double x, y, ang; point() &#123;&#125; point(double _x, double _y, double _ang) &#123; x = _x - l; y = fabs(_y); ang = _ang * pi / 180.0; &#125;&#125;p[maxn];double dp[maxn];int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif int n; scan(n); scan(l, r); r -= l; rep(i, 0, n) &#123; double x, y, ang; scan(x, y, ang); p[i] = point(x, y, ang); &#125; rep(i, 0, (1 &lt;&lt; n)) &#123; rep(j, 0, n) &#123; if((i &amp; (1 &lt;&lt; j)) == 0) &#123; double tmp = atan((r - p[j].x) / p[j].y); tmp = min(tmp, atan((dp[i] - p[j].x) / p[j].y) + p[j].ang); dp[i | (1 &lt;&lt; j)] = max(dp[i | (1 &lt;&lt; j)], p[j].x + p[j].y * tan(tmp)); &#125; &#125; &#125; printf("%.9f\n", dp[(1 &lt;&lt; n) - 1]); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; E-Subway Innovation-前缀和优化+数学推导 如果这nnn个点是按照xxx坐标排好序的，那么我们很容易知道，两两距离之和最短的kkk个点一定是连续的（反证一下即可） 首先用前缀和处理一下xxx坐标的和，即sum[i]sum[i]sum[i]表示前iii个点的xxx坐标之和 令f(i)f(i)f(i)表示从iii开始的kkk个点两两之间的距离之和，我们先求出f(0)f(0)f(0) 添加辅助函数h(i)h(i)h(i)表示前iii个点两两间的距离之和，有h(i)=h(i−1)+xi∗i−sum[i−1]h(i) = h(i - 1) + x_i * i - sum[i - 1]h(i)=h(i−1)+x​i​​∗i−sum[i−1](iii从000开始) 我们令f(0)=h(k−1)f(0) = h(k - 1)f(0)=h(k−1) 接下来推导fff的转移关系，可以看出f(i)f(i)f(i)到f(i−1)f(i - 1)f(i−1)，多出了xi+k−1x_{i + k - 1}x​i+k−1​​到xi...xi+k−2x_i...x_{i + k - 2}x​i​​...x​i+k−2​​的距离，减少了xi−1x_{i - 1}x​i−1​​到xi...xi+k−2x_i...x_{i + k - 2}x​i​​...x​i+k−2​​的距离 f(i)=f(i−1)−(sum[i+k−2]−sum[i−1]−xi−1∗(k−1))+xi+k−2∗k−sum[i+k−1]+sum[i−1]f(i) = f(i - 1)-(sum[i + k - 2] - sum[i - 1] - x_{i - 1} * (k - 1)) + x_{i + k - 2} * k - sum[i + k - 1] + sum[i - 1]f(i)=f(i−1)−(sum[i+k−2]−sum[i−1]−x​i−1​​∗(k−1))+x​i+k−2​​∗k−sum[i+k−1]+sum[i−1] 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct point &#123; int id; ll x; bool operator&lt;(const point &amp;b) const &#123; return x &lt; b.x; &#125;&#125;p[maxn];ll sum[maxn], dp[maxn];int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif int n, k; scan(n); rep(i, 0, n) &#123; scan(p[i].x); p[i].id = i; &#125; sort(p, p + n); sum[0] = p[0].x; rep(i, 1, n) sum[i] = sum[i - 1] + p[i].x; scan(k); rep(i, 1, k) dp[i] = dp[i - 1] + p[i].x * i - sum[i - 1]; dp[0] = dp[k - 1]; ll ans = dp[0], l = 0; rep(i, 1, n - k + 1) &#123; dp[i] = dp[i - 1] - (sum[i + k - 2] - sum[i - 1] - p[i - 1].x * (k - 1)) + (p[i + k - 1].x * (k - 1) - (sum[i + k - 2] - sum[i - 1])); if(ans &gt; dp[i]) &#123; ans = dp[i]; l = i; &#125; &#125; rep(i, l, l + k) printf("%d%c", p[i].id + 1, i == l + k - 1 ? '\n' : ' '); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; F-Dexterina’s Lab-矩阵优化+概率dp dp[i][j]=∑k=0127dp[i−1][k]∗p[j∧k]dp[i][j] = \displaystyle{\sum_{k = 0}^{127}dp[i-1][k]*p[j\wedge k]}dp[i][j]=​k=0​∑​127​​dp[i−1][k]∗p[j∧k] (dp[i][0]dp[i][1]...dp[i][127])=(p[0][0]p[0][1]...p[0][127]p[1][0]p[1][1]...p[1][127]..................p[127][0]p[127][1]...p[127][127])(dp[i−1][0]dp[i−1][1]...dp[i−1][127])\begin{pmatrix} dp[i][0] \\ dp[i][1]\\.\\.\\.\\dp[i][127]\end{pmatrix} = \begin{pmatrix}p[0][0] &amp;&amp;p[0][1]&amp;&amp;...&amp;&amp;p[0][127]\\p[1][0] &amp;&amp;p[1][1]&amp;&amp;...&amp;&amp;p[1][127]\\.&amp;&amp;.&amp;&amp;...&amp;&amp;.\\.&amp;&amp;.&amp;&amp;...&amp;&amp;.\\.&amp;&amp;.&amp;&amp;...&amp;&amp;.\\p[127][0] &amp;&amp;p[127][1]&amp;&amp;...&amp;&amp;p[127][127]\\\end{pmatrix}\begin{pmatrix} dp[i-1][0] \\ dp[i-1][1]\\.\\.\\.\\dp[i-1][127]\end{pmatrix}​⎝​⎜​⎜​⎜​⎜​⎜​⎜​⎛​​​dp[i][0]​dp[i][1]​.​.​.​dp[i][127]​​​⎠​⎟​⎟​⎟​⎟​⎟​⎟​⎞​​=​⎝​⎜​⎜​⎜​⎜​⎜​⎜​⎜​⎜​⎛​​​p[0][0]​p[1][0]​.​.​.​p[127][0]​​​​​​​​​​​​p[0][1]​p[1][1]​.​.​.​p[127][1]​​​​​​​​​​​...​...​...​...​...​...​​​​​​​​​​​p[0][127]​p[1][127]​.​.​.​p[127][127]​​​⎠​⎟​⎟​⎟​⎟​⎟​⎟​⎟​⎟​⎞​​​⎝​⎜​⎜​⎜​⎜​⎜​⎜​⎛​​​dp[i−1][0]​dp[i−1][1]​.​.​.​dp[i−1][127]​​​⎠​⎟​⎟​⎟​⎟​⎟​⎟​⎞​​ 1234567891011121314151617181920212223242526272829303132333435363738int n, K;struct Matrix&#123; double x[128][128];&#125;A,B,ans;Matrix operator * (const Matrix &amp;k1, const Matrix &amp;k2) &#123; mem(B.x, 0); rep(i, 0, n + 1) rep(j, 0, n + 1) rep(k, 0, n + 1) B.x[i][j] += k1.x[i][k] * k2.x[k][j]; return B;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif scan(K, n); rep(i, 0, n + 1) &#123; double k1; scan(k1); rep(j, 0, 128) A.x[j][i^j]=k1; &#125; n = 127; ans=A; K--; while (K) &#123; if (K &amp; 1) ans = ans * A; A = A * A; K &gt;&gt;= 1; &#125; printf("%.11lf\n",1 - ans.x[0][0]); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; G-Count Good Substrings-机智 根据描述最后的串一定是abababa这个样子 若是回文串那么首尾字母一定相同 偶数长度的回文串的来源 一个奇数位置的a和一个偶数位置的a之间 一个奇数位置的b和一个偶数位置的b之间 奇数长度的回文串来源 任意位置的奇偶性相同的两个a或两个b之间的串 单一字符 12345678910111213141516171819202122232425262728293031ll gao(ll n) &#123; return n * (n - 1) / 2LL; &#125;char s[maxn];int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif scan(s); int n = strlen(s); ll oa = 0LL, ea = 0LL, ob = 0LL, eb = 0LL; rep(i, 0, n) &#123; if(i &amp; 1) &#123; if(s[i] == 'a') oa++; else ob++; &#125; else &#123; if(s[i] == 'a') ea++; else eb++; &#125; &#125; dbg(oa * ea + ob * eb); dbg(gao(oa) + gao(ob) + gao(ea) + gao(eb) + n); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; H-Divisors-模拟 先O(x)O(\sqrt x )O(√​x​​​)预处理出xxx的所有因子并且排序，再根据题目描述dfs模拟一下就行 注意对因子去重什么的，免得平方根因子不好搞 1234567891011121314151617181920212223242526272829303132333435int cnt = 0, mnt = 0;ll fac[maxn];void gao(ll x, ll k) &#123; if(cnt &gt; 99999) return; if(x == 1LL || k == 0LL) &#123; dbg(x); cnt++; return; &#125; rep(i, 0, mnt) &#123; if(x &lt; fac[i]) break; if(x % fac[i] == 0) gao(fac[i], k - 1); &#125;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif ll x, k; scan(x, k); for(ll i = 1LL; i * i &lt;= x; i++) &#123; if(x % i == 0) &#123; fac[mnt++] = i; fac[mnt++] = x / i; &#125; &#125; mnt = unique(fac, fac + mnt) - fac; sort(fac, fac + mnt); gao(x, k); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; I-Painting Fence-分治 一个问题的定义，就是找到这个区间中的最短板，把这个长度以下部分横着刷，剩下的以他为中心分为两个区间，每个区间又是相同的子问题 12345678910111213141516171819202122232425int a[maxn];int gao(int l, int r, int minn) &#123; if(l &gt; r) return 0; if(l == r) return a[l] &gt; minn; int m = min_element(a + l, a + r + 1) - a; return min(r - l + 1, gao(l, m - 1, a[m]) + gao(m + 1, r, a[m]) + a[m] - minn);&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout); long _begin_time = clock(); #endif int n; scan(n); rep(i, 1, n + 1) scan(a[i]); dbg(gao(1, n, 0)); #ifndef ONLINE_JUDGE long _end_time = clock(); printf("time = %ld ms\n", _end_time - _begin_time); #endif return 0;&#125; 头文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma comment(linker, "/STACK:1024000000,1024000000")#include &lt;bits/stdc++.h&gt;using namespace std;#define fi first#define se second#define MP(A, B) make_pair(A, B)#define pb push_back#define gcd __gcd#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)#define rep(i, a, b) for(int i = a; i &lt; b; i++)#define per(i, a, b) for(int i = a; i &gt; b; i--)typedef long long ll;typedef unsigned long long ulls;typedef unsigned int uint;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef map&lt;int, int&gt; mii;typedef map&lt;string, int&gt; msi;typedef map&lt;pii, int&gt; mpi;const int INF = 0x3f3f3f3f;const ll LINF = 0x3f3f3f3f3f3f3f3fLL;const ll MOD = 998244353;const double pi = acos(-1.0);const double eps = 1e-6;const int maxn = 1e6 + 5;const int maxm = 1e6 + 5;const int dx[] = &#123;-1, 0, 1, 0, -1, -1, 1, 1&#125;;const int dy[] = &#123;0, 1, 0, -1, 1, -1, 1, -1&#125;;inline int scan(int &amp;a) &#123; return scanf("%d", &amp;a); &#125;inline int scan(int &amp;a, int &amp;b) &#123; return scanf("%d%d", &amp;a, &amp;b); &#125;inline int scan(int &amp;a, int &amp;b, int &amp;c) &#123; return scanf("%d%d%d", &amp;a, &amp;b, &amp;c); &#125;inline int scan(ll &amp;a) &#123; return scanf("%I64d", &amp;a); &#125;inline int scan(ll &amp;a, ll &amp;b) &#123; return scanf("%I64d%I64d", &amp;a, &amp;b); &#125;inline int scan(ll &amp;a, ll &amp;b, ll &amp;c) &#123; return scanf("%I64d%I64d%I64d", &amp;a, &amp;b, &amp;c); &#125;inline int scan(double &amp;a) &#123; return scanf("%lf", &amp;a); &#125;inline int scan(double &amp;a, double &amp;b) &#123; return scanf("%lf%lf", &amp;a, &amp;b); &#125;inline int scan(double &amp;a, double &amp;b, double &amp;c) &#123; return scanf("%lf%lf%lf", &amp;a, &amp;b, &amp;c); &#125;inline int scan(char &amp;a) &#123; return scanf("%c", &amp;a); &#125;inline int scan(char *a) &#123; return scanf("%s", a); &#125;template&lt;class T&gt; inline void mem(T &amp;A, int x) &#123; memset(A, x, sizeof(A)); &#125;template&lt;class T0, class T1&gt; inline void mem(T0 &amp;A0, T1 &amp;A1, int x) &#123; mem(A0, x), mem(A1, x); &#125;template&lt;class T0, class T1, class T2&gt; inline void mem(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, int x) &#123; mem(A0, x), mem(A1, x), mem(A2, x); &#125;template&lt;class T0, class T1, class T2, class T3&gt; inline void mem(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, int x) &#123; mem(A0, x), mem(A1, x), mem(A2, x), mem(A3, x); &#125;template&lt;class T0, class T1, class T2, class T3, class T4&gt; inline void mem(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, int x) &#123; mem(A0, x), mem(A1, x), mem(A2, x), mem(A3, x), mem(A4, x); &#125;template&lt;class T0, class T1, class T2, class T3, class T4, class T5&gt; inline void mem(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5, int x) &#123; mem(A0, x), mem(A1, x), mem(A2, x), mem(A3, x), mem(A4, x), mem(A5, x); &#125;template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt; inline void mem(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5, T6 &amp;A6, int x) &#123; mem(A0, x), mem(A1, x), mem(A2, x), mem(A3, x), mem(A4, x), mem(A5, x), mem(A6, x); &#125;template&lt;class T&gt; inline T min(T a, T b, T c) &#123; return min(min(a, b), c); &#125;template&lt;class T&gt; inline T max(T a, T b, T c) &#123; return max(max(a, b), c); &#125;template&lt;class T&gt; inline T min(T a, T b, T c, T d) &#123; return min(min(a, b), min(c, d)); &#125;template&lt;class T&gt; inline T max(T a, T b, T c, T d) &#123; return max(max(a, b), max(c, d)); &#125;template&lt;class T&gt; inline T min(T a, T b, T c, T d, T e) &#123; return min(min(min(a,b),min(c,d)),e); &#125;template&lt;class T&gt; inline T max(T a, T b, T c, T d, T e) &#123; return max(max(max(a,b),max(c,d)),e); &#125;template&lt;class T&gt; inline void dbg(T a[], int n) &#123; rep(i, 0, n) cout &lt;&lt; a[i] &lt;&lt; (i == n - 1 ? "\n" : " ");&#125;template&lt;class T&gt; inline void dbg(T a) &#123; cout &lt;&lt; a &lt;&lt; " "; &#125;template&lt;class T&gt; inline void dbg(T a[][maxn], int n, int m) &#123; rep(i, 0, n) rep(j, 0, m) cout &lt;&lt; a[i][j] &lt;&lt; (j == m - 1 ? "\n" : " "); &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>题解</tag>
        <tag>CFhM Training</tag>
      </tags>
  </entry>
</search>
